Program ::= {FuncDef | ProcDef | {Statement}}

Type ::= "INTEGER" | "REAL" | "CHAR" | "STRING" | "BOOLEAN"

FuncDef ::= "FUNCTION" IDENT "(" [Params] ")" "RETURNS" Type {Statement} "ENDFUNCTION"
ProcDef ::= "PROCEDURE" IDENT "(" [Params] ")"  "ENDPROCEDURE"

Params ::= Param {"," Param}
Param ::= ["BYVAL" | "BYREF"] IDENT ":" Type

Expr ::= Equality
Equality ::= Comparison {("=" | "<>" | "OR") Comparison}
Comparison ::= Term {("<" | "<=" | ">" | ">=" | "AND") Term}
Term ::= Factor {("+" | "-" | "&") Factor}
Factor ::= Unary {("*" | "/" | "MOD") Unary}
Unary ::= ["+" | "-" | "NOT"] Unary | Pointer
(* The below rule should be the correct one but i do not know how to implement it with a recursive descent parser. *)
(* Pointer ::= "^" Pointer | Pointer "^" | LVal | Call *)
Pointer ::= "^" Pointer | Pointer { "^" } | Call

Args ::= Expr {"," Expr}
Call ::= Primary ["(" [Args] ")"] | "CALL" Primary "(" [Args] ")"

Primary ::= IDENT |
    INTEGER |
    REAL |
    CHAR |
    STRING |
    BOOLEAN |
    "(" Expr ")"|
    Primary "[" Args "]" |
    Primary "." IDENT |
    Call

Statement ::= Decl | TypeDecl | Assign | If | While | Repeat | For | Return
Decl ::= "DECLARE" IDENT ":" Type | "DECLARE" IDENT ":" "ARRAY" "OF" Type
TypeDecl ::= "TYPE" IDENT {Decl} "ENDTYPE" |
    "TYPE" IDENT "=" "(" Value {"," Value} ")" |
    "TYPE" IDENT "=" "^" Type
Assign ::= Expr "<-" Expr
If ::= "IF" Expr "THEN" {Statement} ["ELSE" {Statement}] "ENDIF"
While ::= "WHILE" Expr {Statement} "ENDWHILE"
Repeat ::= "REPEAT" {Statement} "UNTIL" Expr
For ::= "FOR" IDENT "<-" Expr "TO" Expr ["STEP" Expr] {Statement} "NEXT" IDENT
Return ::= "RETURN" Expr
